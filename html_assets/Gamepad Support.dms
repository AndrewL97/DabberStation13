<byondclass name="gamepad">

	<script>

		{

			config: {
				currentGamepad: undefined
			},

			fn: {

				create: function() {
					//alert("Gamepad Control Created.<br/>\n");

					this.getGamepads = navigator.getGamepads || navigator.webkitgetGamepads;

					if(this.getGamepads) {
						//alert("Gamepads allowed.<br/>\n");

						function updateGamepadInformation(e) {
							//alert("Gamepad info updated: ." + e.gamepad.id + e.gamepad.index + e.gamepad.connected + "\n");
							byond.fn.topic("action=gamepad&id=" + e.gamepad.id + "&state=" + e.gamepad.connected);
						}

						window.addEventListener("gamepadconnected",		updateGamepadInformation);
						window.addEventListener("gamepaddisconected",	updateGamepadInformation);

					}

				},

				output: function(obj, sub) {

					switch(obj.list[0].text) {

						case "SetDefaultGamepad":

							if(obj.list[1]) {
								//alert("Setting the default gamepad!\n")

								this.config.currentGamepad = obj.list[1].text;

								if(!this.gamepadLoop) {

									var	gamepad,
										pressedButtons,
										axesPoses,
										anaButtonVals,
										requestAnimationFrame	= window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame,
										_this					= this;

									this.getGamepads.call(navigator).forEach(function(e) {

										if(_this.config.currentGamepad.contains(e.id)) {

											gamepad			= e;
											pressedButtons	= new Array(e.buttons.length);
											anaButtonVals	= new Array(e.buttons.length);
											axesPoses		= new Array(e.axes.length);
											//alert("Set gamepad is now " + e + "\n");
											return;

										}

									});

									function loop() {

										for(var index = 0; index < gamepad.buttons.length; ++ index) {

											if(gamepad.buttons[index].pressed == Boolean(pressedButtons[index]))
												continue;

											pressedButtons[index] = gamepad.buttons[index].pressed;
											_this.input("UpdateButton " +  index + " " + Number(pressedButtons[index]));

										}

										for(var index = 0; index < gamepad.buttons.length; ++ index) {

											if(gamepad.buttons[index].value == anaButtonVals[index])
												continue;

											anaButtonVals[index] = gamepad.buttons[index].value;
											_this.input("UpdateAnaButton " +  index + " " + Number(anaButtonVals[index]));

										}

										for(var index = 0; index < gamepad.axes.length; ++ index) {

											if(gamepad.axes[index] == axesPoses[index])
												continue;

											axesPoses[index] = gamepad.axes[index];
											_this.input("UpdateAxis " +  index + " " + Number(axesPoses[index]));

										}

										requestAnimationFrame.call(window, loop);

									}

									this.gamepadLoop = requestAnimationFrame.call(window, loop);

								}
							}

							else {

								if(this.gamepadLoop) {

									var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame;

									cancelAnimationFrame.call(window, this.gamepadLoop);
									this.gamepadLoop = undefined;
								}

							}

							break;

						case "UpdateGamepads":

							var	gamepads	= (navigator.getGamepads || navigator.webkitGetGamepads || navigator.webkitGamepads).call(navigator),
								gamepadsId	= [];

							if(gamepads && gamepads.length) {

								for(var index = 0; index < gamepads.length; index ++) {

									if(gamepads[index]) {

										gamepadsId.push(gamepads[index].id);

									}

								}

								if(gamepadsId.length) {

									this.topic("action=update_gamepads&" + gamepadsId.toString().replace(",", "&"));
									break;

								}

							}

					}

			}

		}
	}

	</script>

</byondclass>